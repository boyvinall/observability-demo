{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This site shows how to create a Go app that has logs, metrics and traces visible in Grafana.  The Grafana datasources are configured to ensure a seamless click-through experience between each of these signals.  The implementation of metrics and traces within the app makes use of OpenTelemetry-Go, and logging uses the log/slog package that was introduced in Go 1.21.</p> <p>The site is backed by a fully-working demo, so you can easily run it up and explore how to navigate around.  This also means you have a complete reference for how to implement things yourself \u2013\u00a0many other examples online exist only as small fragments, often requiring you to read a bunch of other docs before you have enough to get that *!&amp;$@% thing working.</p> <p>The demo consists of:</p> <ul> <li>Some application components:<ul> <li>GRPC server</li> <li>worker service which receives messages from the GRPC server over NATS</li> <li>command-line app to post requests to the GRPC server</li> </ul> </li> <li>Various infra services:<ul> <li>Grafana \u2013 including provisioned datasources and dashboards</li> <li>Loki/Promtail</li> <li>Tempo</li> <li>Prometheus</li> <li>NATS</li> </ul> </li> </ul> <p>The request flow between the different application components is super simple:</p> <p> </p>"},{"location":"about-docs/","title":"About these docs","text":""},{"location":"about-docs/#mkdocs","title":"Mkdocs","text":""},{"location":"about-docs/#plantuml","title":"PlantUML","text":""},{"location":"about-docs/#snippets","title":"Snippets","text":""},{"location":"logging/","title":"Logging","text":"<p>The use of <code>log/slog</code> gives us easy access to structured logs with no additional dependencies. It allows us to pass around a <code>*slog.Logger</code> that\u2019s pre-configured with various log attributes, and a small helper function gets all the details of log/trace/metric linking out of the way so that application code can focus on logging useful messages.</p>"},{"location":"logging/#capturing-logs","title":"Capturing logs","text":"<p>Promtail is probably the most commonly-used container log shipper, and that\u2019s what we use here.  However, there are (of course) multiple other ways to do this.  Here\u2019s a few of them:</p> <ul> <li>You could use a Loki slog handler that sends directly from the application</li> <li>If you\u2019re using docker, then the Loki docker plugin can be   configured either as the default log driver on your host, or as part of the container instantiation.</li> <li>Vector is also a very capable component, which can pull logs from   docker,   kubernetes or various other sources.</li> </ul> <p>However, Promtail works very well and it means you can easily route all logs from third-party services via the same mechanism used for the application. In this example, we use docker_sd_configs to discover containers. There\u2019s nothing too involved with the setup, probably the main thing to highlight is the adding of some labels via relabel_configs \u2013 this means we can search for logs based on these labels, but without adding any other clutter to the log line itself:</p> <pre><code>relabel_configs:\n  - source_labels: ['__meta_docker_container_name']\n    regex: '/(.*)'\n    target_label: 'container'\n  - source_labels: ['__meta_docker_container_label_com_docker_compose_service']\n    regex: '/(.*)'\n    target_label: 'service'\n  - source_labels: ['__meta_docker_container_label_app']\n    target_label: 'app'\n</code></pre> <p>You can see all the source labels available for relabelling like this on the Promtail web interface, http://localhost:9080/targets. Check the full config here.</p>"},{"location":"logging/#application-code","title":"Application code","text":"<p>We want to make it easy for application developers to get all the signal correlation handled for them.  In our GRPC method, we simply call</p> <pre><code>func (s *server) Boom(ctx context.Context, req *pb.BoomRequest) (*pb.BoomResponse, error) {\n  logger := util.LoggerFromContext(ctx)\n  logger.Info(\"boom\", \"boomer_name\", req.GetName())\n</code></pre> <p>This actually logs something like:</p> <pre><code>time=2023-12-30T10:51:41.680Z level=INFO msg=boom hostname=1984ea724676 service_name=MyBoomerServer trace_id=25bb0819a73da590ee2c533162b4fcfa span_id=3c0b58ad9671b7b3 boomer_name=\"old dude\"\n</code></pre>"},{"location":"logging/#attributes","title":"Attributes","text":"<p>Notice above that some of the log attributes got added automatically. Of particular importance here are the <code>trace_id</code> and <code>span_id</code> attributes, which are pulled from the request context by the util.LoggerFromContext helper function:</p> <pre><code>spanContext := trace.SpanContextFromContext(ctx)\nif spanContext.HasTraceID() {\n    logger = logger.With(\"trace_id\", spanContext.TraceID().String())\n}\nif spanContext.HasSpanID() {\n    logger = logger.With(\"span_id\", spanContext.SpanID().String())\n}\n</code></pre> <p>For GRPC, you setup the necessary context when you instantiate the <code>grpc.Server</code>:</p> <pre><code>grpcServer := grpc.NewServer(\n  grpc.StatsHandler(otelgrpc.NewServerHandler()),\n)\n</code></pre> <p>See reference: grpc.NewServer, grpc.StatsHandler and otelgrpc.NewServerHandler.</p> <p>Note that otelgrpc.UnaryServerInterceptor and stream server interceptors are now deprecated \u2013 although, more generally, <code>grpc</code> unary/stream interceptors are still supported and can be useful for passing additional context values (more on that later).</p> <p>The <code>hostname</code> and <code>service_name</code> attributes in the log line got added as part of the logger instantiation:</p> <pre><code>if hostName := GetResourceHostName(r); hostName != \"\" {\n    logger = logger.With(\"hostname\", hostName)\n}\n\nif serviceName := GetResourceServiceName(r); serviceName != \"\" {\n    logger = logger.With(\"service_name\", serviceName)\n}\n</code></pre> <p>In practice, you might prefer the hostname/servicename there to be added by the Promtail <code>relabel_configs</code>, but sometimes it can be useful to setup some global attributes like that.</p>"},{"location":"tracing/","title":"Tracing","text":""},{"location":"tracing/#grpc","title":"GRPC","text":""},{"location":"tracing/#propagation","title":"Propagation","text":""},{"location":"tracing/#child-span","title":"Child span","text":""}]}